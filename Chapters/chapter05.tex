\chapter{Analysis of isogeny OT protocols}

\section{The twist one}
One of the simplest OT protocols based on isogenies is the one proposed by Lai, Galbraith and de Saint Guilhem in \cite{Lai_twists}; it works in the CSIDH setting, and makes a clever use of the twisting operation.

The protocol written in figure \ref{prot_twist} is two-round and uses a trusted setup curve $E$. It is only proven to be semi-honest in the UC framework, but there is a version with three rounds that is secure with static malicious corruptions.

The third round in the malicious secure version is added as a ``proof of decryption", which makes possible to extract the input of a malicious receiver.

\begin{figure}
    \myproc{Protocol $\Pi_{tw}$}{
        \textbf{Sender} \> \> \textbf{Receiver} \\
        \text{Input: }(m_0, m_1) \> \> \text{Input: }\sigma \\
        s \sample Cl \> \> r \sample Cl \\
        A = s\star E \> \> C = r\star E \\
        \> \> \text{if } \sigma=1: C=C^t \\
        \> \sendmessageleft*{C} \> \\
        k_0 = H(s\star C) \> \>\\
        k_1 = H(s\star C^t) \> \>\\
        c_i = \enc_{k_i}(m_i) \> \> \\
        \> \sendmessageright*{A, (c_0, c_1)} \> \\
        \> \> k_\sigma = H(r\star A) \\
        \> \> m_\sigma= \dec_{k_\sigma}(c_\sigma) \\
    }
    \caption{The twist OT protocol by Lai}
    \label{prot_twist}
\end{figure}


\section{The ``explicit isogeny model"}
Warning: experimental stuff ahead.

We would like to use the Algebraic Group Model in the isogeny setting, since it's very helpful with proofs. However we don't want to restrict too much the power of the adversary. We will thus define a new model, analogous to AGM, and we argue that it doesn't differ too much from the plain model of UC security.

\begin{definition}
    We say that a Turing machine $\adv$ \emph{uses explicit isogenies} if whenever it outputs a supersingular elliptic curve $E$, it also outputs a computable isogeny $\phi:E_1\to E$, where $E_1$ is a curve that it has already seen, or their twist.
\end{definition}
{\color{red} Actually, such isogeny might not exist ... What do we do in such cases??}

We then define what we mean by emulation and realization in this setting, which simply breaks down to the adversary and environment using explicit isogenies.

\begin{definition}
        Given two protocols $\pi$ and $\phi$, we say that $\pi$ \emph{EI-emulates} $\phi$ if for any adversary $\adv$ there is a simulator $\sdv$ such that for any environment $\edv$ with $(\edv,\adv)$ that use explicit isogenies we have that
    $$EXEC_{\phi,\sdv,\edv} \cindist EXEC_{\pi,\adv,\edv}$$
\end{definition}

Finally, a protocol $\pi$ EI-realizes a functionality $\Fun$ if it EI-emulates the protocol $IDEAL_\Fun$.

The EI model is obviously less expressive than the full plain model, but they might be actually closer than they seem. In fact, the following assumption seems to hold:\todo{search references}

\begin{assumption}
    Sampling a supersingular elliptic curve without learning its endomorphism ring is hard.
\end{assumption}

{\color{red}What we actually hope for is something like this:}
\begin{theorem}
    Suppose that the assumption holds. Then if a protocol $\pi$ EI-realizes $\Fun$, $\pi$ also UC-realizes $\Fun$.
\end{theorem}
\begin{proof}
    The proof might go something like this: whenever $\adv$ outputs a supersingular curve $E$, by the assumption it must know its endomorphism ring. But then we can compute an isogeny from $E_0$ (the $j=0$ curve) via the equivalence between EndRing and $\ell$-IsogenyPath.

    So it seems that the assumption implies that all environments and adversaries are actually EI.\todo{Does it really work? Who knows}
\end{proof}

Suppose now that we are in the CSIDH setting, with curves over $\F_p$ and a fixed order $\Oc=\End(E_0)$ inside $K=\Q(\sqrt{-p})$. We have the free and transitive action of $Cl(\Oc)$ on the set $Ell(\Oc)$ of elliptic curves having $\Oc$ as the endomorphism ring (defined over $\F_p$).

In this setting, the EI assumption translates in the adversary being able to output a (smooth) class group element for every supersingular curve it outputs, i.e. always explain $E=x\star E_i$ (or $E_i^t$) for any $E_i$ that it has already seen.

{\color{red} This might not directly translate to the EI assumption, but imposing a smooth degree on the isogeny might work. Another problem is the field of definition of the isogeny; maybe we really need different assumptions for SIDH and CSIDH?}

\subsection{Proving security in the EI model}
We will need a non-committing encryption scheme, such as one-time pad.
\begin{definition}
    An encryption scheme is said to be \emph{non-committing} if there exists PPT algorithms $\rdv_1,\rdv_2$ such that for any $m\in\mathcal M$ the ensembles $(c',k')$ and $(c,k)$ are computationally indistinguishable, where $c'\xleftarrow{}\rdv_1()$, $k'\xleftarrow{}\rdv_2(c', m)$, $k\sample\mathcal K$ and $c\xleftarrow{}\enc_k(m)$.
\end{definition}

This is the big claim:

\begin{theorem}
    The protocol $\Pi_{tw}$ EI-realizes the functionality $\Fun_{OT}$.
\end{theorem}
\begin{proof}
    \textbf{Honest sender and corrupted receiver}: The simulator is defined by the following instructions:
    \begin{enumerate}
        \item Backdoors the trusted setup and sets the curve $E=t\star E_0$, with a randomly sampled $t\in Cl(\Oc)$.
        \item Sets its public key as the honest sender $A=s\star E$.
        \item When receiving the curve $C$ from the adversary, there is also an explanation $C=x\star E_R$, with $E_R=E_0,E$ or $E^t$. If $E_R=E$ it sets $\sigma=0$, if $E_R=E^t$ it sets $\sigma=1$, otherwise it sets $\sigma=-1$. If $\sigma\neq -1$, the simulator queries the functionality and gets the message $m_\sigma$.
        \item The simulator samples two ciphertexts\todo{probably we can use \indcpa} $c_0,c_1\xleftarrow{}\rdv_1()$ and begins to monitor the random oracle queries from the adversary for the following values:
        \begin{itemize}
            \item Query is $s\star C$; if $\sigma\neq0$ aborts, otherwise sets $k_0\xleftarrow{}\rdv_2(c_0,m_0)$ and returns it.
            \item Query is $s\star C^t$; if $\sigma\neq1$ aborts, otherwise sets $k_1\xleftarrow{}\rdv_2(c_1,m_1)$ and returns it.
        \end{itemize}
        \item Finally $\sdv$ sends $A,c_0,c_1$ to the adversary.
    \end{enumerate}
    
    Let $A$ be the event that $\sdv$ aborts. Then we have
    \begin{multline*}
        \left|\prob{\zdv=1}-\prob{\zdv=0}\right| = \left|\condprob{\zdv=1}{A}\cdot\prob{A} + \condprob{\zdv=1}{\neg A}\cdot\prob{\neg A} -\right.\\\left.- \condprob{\zdv=0}{A}\cdot\prob{A} - \condprob{\zdv=0}{\neg A}\cdot\prob{\neg A}\right|\le\\
        \le \left| \condprob{\zdv=1}{A} - \condprob{\zdv=0}{A}\right|\cdot\prob{A}  +\\
        + \left| \condprob{\zdv=1}{\neg A} - \condprob{\zdv=0}{\neg A}\right|\cdot\prob{\neg A} \le \\
        \le \prob{A} + \left| \condprob{\zdv=1}{\neg A} - \condprob{\zdv=0}{\neg A}\right|
    \end{multline*}

    The theorem will then follow from the fact that both quantities are negligible. Indeed if $\sdv$ aborts, then we can solve a CSIDH problem, while if $\zdv$ can distinguish we can break the non-committing property of the encryption scheme.\todo{or \indcpa}
    
    Suppose now that we have a CSIDH problem $E_1=a\star E_0$ we want to solve. We create two possible solvers for this problem:
    \begin{itemize}
        \item Algorithm $\ddv_1$ will run $\sdv$ with $E_1$ as the trusted setup; then it will check if it can compute $a$ from the queries and explanations that $\zdv$ makes to the random oracle.
        \item Algorithm $\ddv_2$ will run $\sdv$ with $b\star E_0$ as a trusted setup and $b\star E_1$ as the public key of the sender; then it will check queries to compute a value $a'$ such that $a'\star(b\star E_0)=b\star E_1$, which means $a'=a$.
    \end{itemize}
    
    In table \ref{tab_dlogs} we show how $\ddv_1$ and $\ddv_2$ can compute the solutions from the query. The rows are indexed by the explanation of the curve $C$ and the query, while the columns are the explanation of the query.
    
    \begin{table}[]
        \centering
        \begin{tabular}{c|ccccc}
            & $y\star E_0$ & $y\star E$ & $y\star E^t$ & $y\star A$ & $y\star A^t$ \\
            \hline
            $C=x\star E_0$, $s\star C$ & $s=yx^{-1}$ & $s=ytx^{-1}$ & $s=yt^{-1}x^{-1}$ & $t=xy^{-1}$ & $s^2=x^{-1}t^{-1}$ \\ 
            $C=x\star E_0$, $s\star C^t$ & $s=yx$ & $s=ytx$ & $s=yt^{-1}x$ & $t=x^{-1}y^{-1}$ & $s^2=xt^{-1}$ \\
            $C=x\star E$, $s\star C^t$ & $s=xyt$ & $s=xyt^2$ & $s=xy$ & $t=x^{-1}y^{-1}$ & $s^2=xy$ \\
            $C=x\star E^t$, $s\star C$ & $s=x^{-1}yt$ & $s=x^{-1}yt^2$ & $s=x^{-1}y$ & $t=xy^{-1}$ & $s^2=x^{-1}y$ \\
        \end{tabular}
        \caption{The computable solutions to the CSIDH problem}
        \label{tab_dlogs}
    \end{table}
    
    We now compute $\prob{\sdv\text{ aborts}}$ and estimate it with the advantages of $\ddv_1,\ddv_2$ for the CSIDH problem.
    
    Indeed we have
    \begin{multline*}
        \prob{\sdv\text{ aborts}} = \prob{C=x\star E_0 \et \text{ queried } s\star C \text{ or } s\star C^t} \\
        +\prob{C=x\star E \et \text{ queried } s\star C^t} \\
        + \prob{C=x\star E^t \et \text{ queried } s\star C} \\
        = \left(\prob{(C=x\star E_0) \et (s\star C \text{ or } s\star C^t) \et (y\star A)}\right. \\
        + \left.\prob{C=x\star E \et s\star C^t \et y\star A} + \prob{C=x\star E^t \et s\star C \et y\star A}\right)\\
        + \left(\prob{(C=x\star E_0) \et (s\star C \text{ or } s\star C^t) \et \neg(y\star A)}\right.\\
        + \left.\prob{C=x\star E \et s\star C^t \et \neg(y\star A)} + \prob{C=x\star E^t \et s\star C \et \neg(y\star A)}\right)\\
        \le \advantage{CSIDH}{\ddv_1}[] + \advantage{CSIDH}{\ddv_2}[]
    \end{multline*}\todo{is this computation right? I highly doubt so...}
    
\end{proof}
